\hypertarget{class_h_a_l_1_1_algorithms_1_1_import_particle}{\section{H\+A\+L\+:\+:Algorithms\+:\+:Import\+Particle Class Reference}
\label{class_h_a_l_1_1_algorithms_1_1_import_particle}\index{H\+A\+L\+::\+Algorithms\+::\+Import\+Particle@{H\+A\+L\+::\+Algorithms\+::\+Import\+Particle}}
}


Generic algorithm class that builds particles from information in a T\+Tree.  




{\ttfamily \#include $<$Algorithms.\+h$>$}

Inheritance diagram for H\+A\+L\+:\+:Algorithms\+:\+:Import\+Particle\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_h_a_l_1_1_algorithms_1_1_import_particle}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_h_a_l_1_1_algorithms_1_1_import_particle_ab42dcac49ed8ae1f565346ec7372c7a5}{Import\+Particle} (T\+String name, T\+String title, unsigned n\+\_\+max=0)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_h_a_l_1_1_algorithms_1_1_import_particle_a1e5924b9deb6c7d1c1d1734b8cb510cb}{virtual void {\bfseries Exec} (Option\+\_\+t $\ast$)}\label{class_h_a_l_1_1_algorithms_1_1_import_particle_a1e5924b9deb6c7d1c1d1734b8cb510cb}

\item 
\hypertarget{class_h_a_l_1_1_algorithms_1_1_import_particle_abad1a5a9b44becfae4e4a7113edc80eb}{virtual T\+Lorentz\+Vector $\ast$ {\bfseries Make\+T\+L\+V} (unsigned)}\label{class_h_a_l_1_1_algorithms_1_1_import_particle_abad1a5a9b44becfae4e4a7113edc80eb}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Generic algorithm class that builds particles from information in a T\+Tree. 

This algorithm imports the information to build particles from specified branches in a T\+Tree. It may use the branches to build particles with either full 4-\/vector momentum or transverse momentum. It can optionally read in the charge, particle I\+D, and number of particles to import. It determines how to read in the particles through the specified branch maps given to the \hyperlink{class_h_a_l_1_1_analysis}{Analysis} object. It can also determine how many particles to read in based on whether you give a number to read, branchmap to scan, or implicitly gather it from the length of the other required branches. The necessary branch maps are given below. The particles from this algorithm are stored in a \hyperlink{class_h_a_l_1_1_generic_data}{Generic\+Data} object in the User\+Data under the algorithm's name.~\newline
~\newline
{\bfseries Explaination of the branch maps\+:}~\newline
The required maps are those needed to construct the T\+Lorentz\+Vectors, either complete vectors or just transverse vectors. Any set of the branch maps given below will do. $<$name$>$ refers to the name given to this algorithm's constructor.~\newline
{\itshape Required Branch Maps\+:} \begin{TabularC}{6}
\hline
\rowcolor{lightgray}\PBS\centering {\bf Cartesian components }&\PBS\centering {\bf $ p_T,\eta,\phi,E$ }&\PBS\centering {\bf $ p_T,\eta,\phi,m$ }&\PBS\centering {\bf Transverse Cartesian }&\PBS\centering {\bf $ p_T,\phi$ }&\PBS\centering {\bf $ E_T,\phi$  }\\\cline{1-6}
\PBS\centering $<$name$>$\+:x0 &\PBS\centering $<$name$>$\+:pt &\PBS\centering $<$name$>$\+:pt &\PBS\centering $<$name$>$\+:x1 &\PBS\centering $<$name$>$\+:pt &\PBS\centering $<$name$>$\+:et \\\cline{1-6}
\PBS\centering $<$name$>$\+:x1 &\PBS\centering $<$name$>$\+:eta &\PBS\centering $<$name$>$\+:eta &\PBS\centering $<$name$>$\+:x2 &\PBS\centering $<$name$>$\+:phi &\PBS\centering $<$name$>$\+:phi \\\cline{1-6}
\PBS\centering $<$name$>$\+:x2 &\PBS\centering $<$name$>$\+:phi &\PBS\centering $<$name$>$\+:phi &\PBS\centering &\PBS\centering &\PBS\centering \\\cline{1-6}
\PBS\centering $<$name$>$\+:x3 &\PBS\centering $<$name$>$\+:e &\PBS\centering $<$name$>$\+:m &\PBS\centering &\PBS\centering &\PBS\centering \\\cline{1-6}
\end{TabularC}
{\itshape Optional Branch Maps\+:} \begin{TabularC}{3}
\hline
\rowcolor{lightgray}\PBS\centering {\bf Number of particle }&\PBS\centering {\bf Charge }&\PBS\centering {\bf I\+D  }\\\cline{1-3}
\PBS\centering $<$name$>$\+:nentries &\PBS\centering $<$name$>$\+:charge &\PBS\centering $<$name$>$\+:id \\\cline{1-3}
\end{TabularC}
{\bfseries Examples\+:}~\newline
In your analysis file, do the following to import Monte Carlo particles with complete 4-\/vectors\+:


\begin{DoxyCode}
\hyperlink{class_h_a_l_1_1_analysis}{HAL::Analysis} a(\textcolor{stringliteral}{"sample analysis"}, \textcolor{stringliteral}{""}, \textcolor{stringliteral}{"truth"});

a.AddAlgo(\textcolor{keyword}{new} \hyperlink{class_h_a_l_1_1_algorithms_1_1_import_particle}{HAL::Algorithms::ImportParticle}(\textcolor{stringliteral}{"mc"}, \textcolor{stringliteral}{"import basic Monte
       Carlo particles"}));

\textcolor{comment}{//...}

a.MapBranch(\textcolor{stringliteral}{"mc\_pt"},     \textcolor{stringliteral}{"mc:pt"});
a.MapBranch(\textcolor{stringliteral}{"mc\_eta"},    \textcolor{stringliteral}{"mc:eta"});
a.MapBranch(\textcolor{stringliteral}{"mc\_phi"},    \textcolor{stringliteral}{"mc:phi"});
a.MapBranch(\textcolor{stringliteral}{"mc\_m"},      \textcolor{stringliteral}{"mc:m"});
a.MapBranch(\textcolor{stringliteral}{"mc\_pdgId"},  \textcolor{stringliteral}{"mc:id"});
a.MapBranch(\textcolor{stringliteral}{"mc\_charge"}, \textcolor{stringliteral}{"mc:charge"});
\end{DoxyCode}
 Likewise, you can import the M\+E\+T vector like so\+:


\begin{DoxyCode}
\hyperlink{class_h_a_l_1_1_analysis}{HAL::Analysis} a(\textcolor{stringliteral}{"sample analysis"}, \textcolor{stringliteral}{""}, \textcolor{stringliteral}{"truth"});

a.AddAlgo(\textcolor{keyword}{new} \hyperlink{class_h_a_l_1_1_algorithms_1_1_import_particle}{HAL::Algorithms::ImportParticle}(\textcolor{stringliteral}{"met"}, \textcolor{stringliteral}{"import the MET
       tranverse vector"}));

\textcolor{comment}{//...}

a.MapBranch(\textcolor{stringliteral}{"MET\_Truth\_Int\_etx"}, \textcolor{stringliteral}{"met:x1"});
a.MapBranch(\textcolor{stringliteral}{"MET\_Truth\_Int\_ety"}, \textcolor{stringliteral}{"met:x2"});
\end{DoxyCode}
 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_h_a_l_1_1_algorithms_1_1_import_particle_ab42dcac49ed8ae1f565346ec7372c7a5}{\index{H\+A\+L\+::\+Algorithms\+::\+Import\+Particle@{H\+A\+L\+::\+Algorithms\+::\+Import\+Particle}!Import\+Particle@{Import\+Particle}}
\index{Import\+Particle@{Import\+Particle}!H\+A\+L\+::\+Algorithms\+::\+Import\+Particle@{H\+A\+L\+::\+Algorithms\+::\+Import\+Particle}}
\subsubsection[{Import\+Particle}]{\setlength{\rightskip}{0pt plus 5cm}H\+A\+L\+::\+Algorithms\+::\+Import\+Particle\+::\+Import\+Particle (
\begin{DoxyParamCaption}
\item[{T\+String}]{name, }
\item[{T\+String}]{title, }
\item[{unsigned}]{n\+\_\+max = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}\label{class_h_a_l_1_1_algorithms_1_1_import_particle_ab42dcac49ed8ae1f565346ec7372c7a5}


Constructor. 

Initializes the algorithm 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & Name of the algorithm. This can be used as the input to other algorithms. \\
\hline
\mbox{\tt in}  & {\em title} & Description of the algorithm. Can be an empty string. \\
\hline
\mbox{\tt in}  & {\em n\+\_\+max} & Maximum number of particles to import. If n=0 then all the particles are imported. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{class_h_a_l_1_1_algorithms_1_1_import_bool}{Import\+Bool}, \hyperlink{class_h_a_l_1_1_algorithms_1_1_import_integer}{Import\+Integer}, \hyperlink{class_h_a_l_1_1_algorithms_1_1_import_counting}{Import\+Counting}, \hyperlink{class_h_a_l_1_1_algorithms_1_1_import_decimal}{Import\+Decimal} 
\end{DoxySeeAlso}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/jhetherly/src/root\+\_\+\+H\+A\+L/include/\+H\+A\+L/\hyperlink{_algorithms_8h}{Algorithms.\+h}\end{DoxyCompactItemize}
